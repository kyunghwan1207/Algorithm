- `n`개의 값과 값 `k`가 주어지면, `n`개의 값 중에서 `k`번째로 작은 수를 찾는 문제가 selection 문제라 한다

- `n`개의 값을 `A`에 저장한다

- Selection 알고리즘은 여러 방향으로 설계할 수 있다
    1. Algorithm_SORT: `A`를 오름차순으로 정렬한 후 `A[k-1]`를 리턴한다

        - **단점**: O(nlogn) 시간이 필요

        - **장점**: 단순 알고리즘

    2. Algorithm_QUICK: `quick_select(A, k)`를 호출한다

        - **단점**: 최악의 경우의 시간 O(n^2)

        - **장점**: 평균적인 시간 O(n)

    3. Algorithm_MoM: `MoM(A, k)`를 호출한다

        - **장점**: 최악의 경우의 시간은 O(n) < 최적의 시간

        - **단점**: 숨겨진 상수가 커서 실제 수행시간이 클 수 있다

    - 위의 세 알고리즘과는 조금 다른 방식을 생각해보자!
    4. Algorithm_HEAP: 힙을 이용한 selection 알고리즘

        1. `A`의 값을 min 힙으로 만든 후: O(n) 시간

        2. 힙 성질을 이용해 `k`번째로 작은 수를 찾는다:  시간

            O(?)

        3. 힙 성질 (heap property)은 부모 노드의 값이 자식 노드의 값보다 크지 않다는 것이다

- **입력**: 힙 성질을 만족하는 배열 `A`의 값을 입력받고 `k` 값도 입력받는다

- `1 <= k <= n`

- `1 <= n <= 100,000`

- **출력**: `A`에서 `k`번째로 작은 값을 출력한다
- **할일**: 알고리즘의 두 번째 단계(`Algorithm_HEAP`)를 설계하는 것이다. 되도록 수행시간이 작아야 한다

Algorithm_HEAP

- **주석**: 본인의 알고리즘을 설명하고 수행시간을 분석하는 주석을 반드시 포함해야 한다

- 다른 세 가지 알고리즘과 비교해 본인의 알고리즘의 장점과 단점도 설명해야 한다

- Python의 `heapq` 모듈에서 min 힙을 제공한다. 필요하면 min 힙을 추가로 사용해도 된다

```python

>>> import heapq

>>> A = [5, 4, 2, 7] # 리스트를 힙 자료구조로 사용한다

>>> heapq.heapify(A) # A의 값들이 힙 성질 만족하게 됨

>>> A

[2, 4, 5, 7]

>>> heapq.heappush(A, 1) # insert 1 into A

>>> A

[1, 2, 5, 7, 4]

>>> A[0] # just print min of A (not deleted)

1

>>> heapq.heappop(A) # delete min key and return

1

>>> A

[2, 4, 5, 7]
```