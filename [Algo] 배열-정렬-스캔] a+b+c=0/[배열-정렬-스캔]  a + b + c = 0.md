# [배열-정렬-스캔]  a + b + c = 0 ?

+ 정수가 저장된 세 개의 리스트 `A`, `B`, `C` 에 대해,  `a->A, b->B, c->C`를 선택해 `a+b+c=0`이 되는 `(a,  b, c)`쌍이 존재하는지 알고싶다.
+ 이를 풀기 위해, 조금 더 간단한 문제를 생각해보자.
  + 정수가 저장된 두 개의 리스트 `X`, `Y`와 특정 정수 `z`에 대해, `x->X, y->Y`를 선택해 `x+y=z`가 되는 `(x, y)` 쌍을 존재하는지 검사하는 문제
  + 함수 `two_sum(X, Y, t)`는 그런 쌍이 하나라도 존재하면 `True`를 return하고 그렇지 않으면 `False`를 return하는 함수이다.
+ **입력** : 첫 번째 줄에 한 개 이상의 정수는 `A`에 저장하고, 두 번째 줄에 주어진 한 개 이상의 정수는 `B`에 저장하고, 세 번째 줄에 주어진 한 개 이상의 정수는 `C`에 저장
+ **출력**:  `a->A, b->B, c->C`를 선택해 `a+b+c=0`이 되는 `(a,  b, c)`쌍이 존재하면 `True`를 return하고 그렇지 않으면 `False`를 return한다.
+ **주석**: 코드의 수행시간을 간략히 분석하고 Big-O로 표기하시오
+ **힌트**: 
  + `two_sum(X, Y, t)`을 **O(n^2)** 시간에 동작하도록하는 건 매우쉽다. Z의 값을 t라고 하고 이 함수를 n번 호출하면 문제가 풀리기에 총 O(n^3)시간에 문제가 풀립니다.
  + O(n^3)보다 더 빠르게 하려면 `two_sum(X, Y, t)`을 **O(n^2)**보다 더 빠르게 해야 합니다.
  + 우선 `two_sum(X, Y, t)` 을 호출하기 전에 `X`,  `Y`를 정렬합니다.
  + 정렬된 `X` `Y` 를 가지고 `two_sum(X, Y, t)` 을 호출합니다. 합이 `t`가 되는 `x, y`원소를 찾는 것인데, `X, Y`는 정렬되어 있기에 두 리스트를 스캔하면서 선형시간에 찾을 수 있습니다.
  + `two_sum(X, Y, t)` 을 O(n^2)보다 더 빠르게 하는 다른 방법은 Hash Table을 사용하는 것입니다. 정렬을 미리 하지 않고, 해시 테이블을 이용하는 것입니다. 이 경우에는 최악의 경의 시간이 아닌 평균시간으로 `two_sum(X, Y, t)` 을 **O(n)**시간에 수행할 수 있습니다.



```python
입력1
3 1 2 3
-3 0 -2
1 -1 2
출력1
True

입력2
4 3 1 1
7 1 3
3 -1 2 5
출력2
False

입력3
-9 1 4 2
-2 5
1 -3 -3
출력3
True
```

