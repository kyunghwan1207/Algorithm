**[DP] 히스토그램 (Histogram) 구하기**

- 데이터 i의 빈도수 F[i]가 입력으로 주어진다. 예를 들어, F = [4, 2, 3, 6, 5, 6, 12, 16]이라면 데이터 0번은 4번 등장하고, 데이터 1번은 2번 등장하는 식이다
- 우리는 빈도수를 최대 B개의 연속된 빈도수의 그룹으로 묶으려고 한다. 예를 들어, F[0] - F[3] 그룹과 F[4] - F[7] 그룹, 두 그룹으로 묶는다고 하자. 이왕이면, 빈도수가 비슷한 값들을 하나의 그룹으로 묶어 빈도수의 원래 분포를 더 잘 반영하고 싶다
- 한 **그룹의 오차**(error)는 그룹의 빈도수의 평균 값과 개별 값의 차이의 제곱한 값으로 정의한다. 즉, (개별 빈도수 - 그룹의 평균 값)^2의 합으로 정의한다
    - 예를 들어, 위의 두 그룹 [4, 2, 3, 6]과 [5, 6, 12, 16]에 대해서, 첫 번째 그룹의 평균 3.75, 두 번째 그룹의 평균 9.75이다.
    - 첫 번째 그룹의 오차는 (4-3.75)^2 + (2-3.75)^2 + (3-3.75)^2 + (6-3.75)^2 = 8.75이 된다
    - 두 번째 그룹의 오차는 같은 방법으로 계산해 보면, 80.75가 된다
- 한 **묶음의 오차**(error)은 각 그룹의 오차의 합으로 정의한다.
    - 위의 예에서 설명한 묶음의 오차는 8.75 + 80.75 = 89.5이다
- 묶음을 다르게 해보면 묶음의 오차도 달라진다
    - 이번에도 두 그룹으로 나누는데, 첫 번째 그룹은 [4, 2, 3, 6, 5, 6], 두 번째 그룹은 [12, 16]으로 해보자
    - 같은 방식으로 묶음의 오차를 계산해보면 21.3333으로 앞에서 설명한 묶음의 오차보다 작다!
- 여러분은 오차가 최소인 묶음을 찾아야 한다
    - 이 문제를 **히스토그램 (묶음) 문제**라 한다
- **입력**: 첫 줄에는 최대 그룹 수 B와 n이 주어진다. 다음 n개의 줄에는 빈도수 F[i]가 주어진다
    - 1 <= B <= 30, 1 <= n <= 1,000
- **출력**: 최대 B개의 그룹으로 F의 연속된 값으로 그룹을 만드는데, 오차가 최소인 묶음을 찾아 최소 오차 값을 출력
    - 단, 소수점 아래 4째 자리에서 반올림해서 3째 자리까지만 출력한다! (함수 이용)
        
        round
        
    - round(x, 3)이라고 하면 x의 소수점 아래 4째자리에서 반올림해서 3째 자리까지만 계산한다
- **힌트:** 한 그룹의 오차를 식으로 표현해 간단한 형식으로 정리해보면, 빠른 시간에 계산할 수 있는 방법을 찾을 수 있다
- 주석: 알고리즘을 간략히 설명하고 수행시간 분석을 하세요. (필수)

**입/출력 예시**

**예시 1**

입력

```python
2 8
4
2
3
6
5
6
12
16
```

출력

```python
21.333
```

**예시 2**

입력

```python
3 8
1
2
3
4
5
6
7
8
```

출력

```python
4.5
```

⋇ 입출력 형식을 잘 지켜주세요