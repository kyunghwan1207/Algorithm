**무조건 오름차순으로 만들어보자~**

- **입력**: `n`개의 정수 값이 주어진다. 이 값들을 리스트에 `A`에 저장한다고 하자
    - `1 <= n <= 1,000`
    - `1 <= 정수 값 <= 200`
- 다음과 같은 연산을 생각해보자
    - `A[i] = A[i] + 1` 또는 `A[i] = A[i] - 1`
- `A`의 값들에 연산을 원하는 만큼 적용해서 오름차순이 되도록 변경할 수 있다
    - 즉, `A[0] <= A[1] <= ... <= A[n-1]`이 되도록 변경할 수 있다
- **출력**: A의 값들이 **오름차순이 되기 위해 필요한** 연산의 **최소 횟수**
- **주석1**: 본인이 작성한 알고리즘을 간단 명료하게 설명한다
- **주석2**: 알고리즘의 수행시간을 간단히 분석한 후, 수행 시간을 Big-O로 표기한다

**입/출력 예시**

**예시 1**

입력

```python
1 2 3 2 1
```

출력

```python
2
```

설명

```python
1 -> 2 -> 3 까진 오름차순 조건이 만족합니다.
하지만 이후에 오는 2와 1은 오름차순을 위배됩니다.
이때 2와 1을 각각 3으로 만들어서 1 2 3 3 3으로 오름차순을 만족시킬 수도 있지만
이때 필요한 연산횟수는 2를 3으로 만들 때 -> 1번 ( "A[i] = A[i] + 1" 연산 1회) ,
1을 3으로 만들 때 -> 2번( "A[i] = A[i] + 1" 연산 2회)이 필요하므로 총 3번의 연산이 필요합니다.
다른 방법으로 접근해보면
1 -> 2 -> 3에서 3을 2로 바꾸면 어떨까요?
1 -> 2 -> 2 -> 2 -> 2 가 된다면 오름차순 조건을 만족할 것입니다.
이때의 연산횟수를 살펴보면 3을 2로 바꿀 때 1번, 2는 이미 2이므로 연산 수행x, 
1을 2로 바꿀 때 1번 총 2번의 연산만으로 오름차순으로 만들 수 있어서
결과적으로 최소연산횟수인 2가 정답입니다.
```

**예시 2**

입력

```python
5 4 3 2 1
```

출력

```python
6
```

설명
```python
5 를 3으로 바꾸고(2회), 4를 3으로 바꾸고(1회), 2와 1도 각각 3으로 바꾸면(1+2 회) 3 3 3 3 3으로 오름차순을 만족하괴 되어 총 6회의 연산이 필요합니다.
```

**예시 3**

입력

```python
1 2 2 4 4
```

출력

```python
0
```

설명
```python
이미 오름차순 조건을 만족하고 있기 때문에 연산이 필요하지 않습니다.
```